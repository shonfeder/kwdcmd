<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Kwdcmd (kwdcmd.Kwdcmd)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">kwdcmd</a> &#x00BB; Kwdcmd</nav><header class="odoc-preamble"><h1>Module <code><span>Kwdcmd</span></code></h1></header><nav class="odoc-toc"><ul><li><a href="#kwdcmd:-keywords-to-write-command-lines">Kwdcmd: Keywords to Write Command Lines</a><ul><li><a href="#ideals">Ideals</a></li><li><a href="#usage">Usage</a><ul><li><a href="#a-single-command-parser">A single command parser</a></li><li><a href="#a-sub-command-parser">A sub-command parser</a></li></ul></li><li><a href="#bindingops">Binding operators</a></li><li><a href="#constructors">Constructing terms</a></li><li><a href="#executing-clis">Executing CLIs</a></li><li><a href="#re-exports-from-cmdliner">Re-exports from cmdliner</a></li></ul></li></ul></nav><div class="odoc-content"><h2 id="kwdcmd:-keywords-to-write-command-lines"><a href="#kwdcmd:-keywords-to-write-command-lines" class="anchor"></a>Kwdcmd: Keywords to Write Command Lines</h2><p>Kwdcmd is a lightweight and partial porcelain around <a href="https://erratique.ch/software/cmdliner">Cmdliner</a>.</p><p>Cmdliner is a powerful library for composable command line interfaces, but it is relatively low level. Use of the combinators without reference to the docs requires a deep and thorough knowledge of the library. Kwdcmd wants to be able to be used without having to consult the docs.</p><p>This thin wrapper library is best thought of as an executable cookbook for common Cmdliner usage patterns, or as programmatic documentation encoded in the type level.</p><p>The recipes are divided between module namespaces and detailed with named function arguments.</p><h3 id="ideals"><a href="#ideals" class="anchor"></a>Ideals</h3><ul><li>Remain true to Cmdliners compositional principles (no side-effecting shortcuts or other chicanery).</li><li>Unfamiliar users should be able to write their CLIs within 10 minutes of reading the docs.</li><li>Familiar users should find everything they need to know to write clean, expressive CLIS's self-documented in the type signatures of the library's modules and functions.</li></ul><p>Please <a href="https://github.com/shonfeder/kwdcmd/issues/new">open an issue</a> or <a href="https://github.com/shonfeder/kwdcmd/blob/master/CONTRIBUTING.org">add a feature</a> if you think the library could be improved to better meet these ideals.</p><h3 id="usage"><a href="#usage" class="anchor"></a>Usage</h3><p>The basic usage pattern is as follows:</p><ul><li>Define Cmdliner <code>terms</code>, i.e., parsers producing values from CLI arguments, using the <a href="#constructors">constructors</a>.</li><li>Use the <a href="#bindingops">binding operators</a> to declare a collection of term parsers which are then fed to a program.</li><li>Apply an <a href="#executors">executor</a> to run the parser and the program.</li></ul><p>CLI programs are defined either as a single command or with multiple subcommands. Here are two short examples to illustrate each case:</p><h4 id="a-single-command-parser"><a href="#a-single-command-parser" class="anchor"></a>A single command parser</h4><pre><code>open Kwdcmd

(** Application configuration *)
type kind =
  | Bin
  | Lib

type config =
  { name : string
  ; kind : kind
  }

(** Application executor *)
let run : config -&gt; unit = fun _config -&gt; print_endline &quot;TODO&quot;

(** CLI entrypoint *)
let () =
  Exec.run ~name:&quot;My application&quot; ~version:&quot;0.0.1&quot; ~doc:&quot;project generator&quot;
  @@ let+ name =
       Required.pos
         &quot;NAME&quot;
         ~conv:Arg.string
         ~nth:0
         ~doc:&quot;The name of the new project&quot;
         ()
  and+ kind =
    Optional.(
      flag_choice
        ~default:Bin
        [ c ~name:&quot;bin&quot; Bin ~doc:&quot;create an executable binary&quot;
        ; c ~name:&quot;lib&quot; Lib ~doc:&quot;create a library&quot;
        ])
  in
  run { name; kind }</code></pre><h4 id="a-sub-command-parser"><a href="#a-sub-command-parser" class="anchor"></a>A sub-command parser</h4><p>A sub-command interface to a simple utility for looking up emoji:</p><pre><code>module Example_cli (Progn : sig
    val lookup_name : string -&gt; (unit, _ err) cmd_result
    val lookup_unicode : string -&gt; (unit, _ err) cmd_result
    val emojify : Fpath.t -&gt; (unit, _ err) cmd_result
  end )
= struct
  open Kwdcmd

  let () =
    Exec.commands
      ~name:&quot;emojitsu&quot;
      ~version:&quot;0.0.1&quot;
      ~doc:&quot;Techniques for dealing with emoji&quot;
      [ ( cmd
            ~name:&quot;find-name&quot;
            ~doc:&quot;Find the name of an emoji given its unicode&quot;
          @@ let+ unicode = Required.pos &quot;UNICODE&quot; ~conv:Arg.string ~nth:0 () in
          Progn.lookup_name unicode )
      ; ( cmd
            ~name:&quot;find-unicode&quot;
            ~doc:&quot;Find the unicode of an emoji given its name&quot;
          @@ let+ name = Required.pos &quot;EMOJI_NAME&quot; ~conv:Arg.string ~nth:0 () in
          Progn.lookup_unicode name )
      ; ( cmd
            ~name:&quot;emojify&quot;
            ~doc:
              &quot;Replace all names of the form :emoji_name: with the corresponding \
               unicode in the given file&quot;
          @@ let+ name =
               Required.pos
                 &quot;FILE&quot;
                 ~conv:Arg.(conv (Fpath.of_string, Fpath.pp))
                 ~nth:0
                 ()
          in
          Progn.emojify name )
      ]
end</code></pre><h3 id="bindingops"><a href="#bindingops" class="anchor"></a>Binding operators</h3><p>The beauty of Cmdliner lies in its its composable, applicative API. Use of this API is made cleaner by means of the binding operators. Naturally, you are not bound to use these.</p><p>The general schema is</p><pre><code>let+ value_1 = term_1
and+ value_2 = term_2
(* ... *)
and+ value_n = term_n
in
program value_1 value_2 (* ... *) value_n</code></pre><p>where each <code>value_i</code> will be the value obtained by parsing by the the CLI term specified in <code>term_i</code>.</p><p>See the example above for usage.</p><div class="odoc-spec"><div class="spec value" id="val-let+" class="anchored"><a href="#val-let+" class="anchor"></a><code><span><span class="keyword">val</span> let+ : <span><span><span class="type-var">'a</span> <span class="xref-unresolved">Cmdliner</span>.Term.t</span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="xref-unresolved">Cmdliner</span>.Term.t</span></span></code></div><div class="spec-doc"><p><code>(let+)</code> is <code>Term.(const f $ t)</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-and+" class="anchored"><a href="#val-and+" class="anchor"></a><code><span><span class="keyword">val</span> and+ : 
  <span><span><span class="type-var">'a</span> <span class="xref-unresolved">Cmdliner</span>.Term.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'b</span> <span class="xref-unresolved">Cmdliner</span>.Term.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <span class="xref-unresolved">Cmdliner</span>.Term.t</span></span></code></div><div class="spec-doc"><p><code>(and+)</code> is <code>Term.(const (fun x y -&gt; (x, y)) $ a $ b)</code></p></div></div><h3 id="constructors"><a href="#constructors" class="anchor"></a>Constructing terms</h3><p>We build our CLIs by defining composable terms that transform CLI args into OCaml values. Kwdcmd breaks terms into 2 classes.</p><div class="odoc-spec"><div class="spec module" id="module-Required" class="anchored"><a href="#module-Required" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Required/index.html">Required</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Optional" class="anchored"><a href="#module-Optional" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Optional/index.html">Optional</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-cmd" class="anchored"><a href="#type-cmd" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a cmd</span></span><span> = <span><span class="type-var">'a</span> <span class="xref-unresolved">Cmdliner</span>.Term.t</span> * <span class="xref-unresolved">Cmdliner</span>.Cmd.info</span></code></div><div class="spec-doc"><p>The type of subcommands</p></div></div><div class="odoc-spec"><div class="spec value" id="val-cmd" class="anchored"><a href="#val-cmd" class="anchor"></a><code><span><span class="keyword">val</span> cmd : 
  <span>?man:<span><span class="xref-unresolved">Cmdliner</span>.Manpage.block list</span> <span class="arrow">&#45;&gt;</span></span>
  <span>name:string <span class="arrow">&#45;&gt;</span></span>
  <span>doc:string <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <span class="xref-unresolved">Cmdliner</span>.Term.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <span class="xref-unresolved">Cmdliner</span>.Cmd.t</span></span></code></div><div class="spec-doc"><p>A subcommand</p></div></div><div class="odoc-spec"><div class="spec type" id="type-err" class="anchored"><a href="#type-err" class="anchor"></a><code><span><span class="keyword">type</span> <span>'err err</span></span><span> = <span>[&gt; <span>`Msg of string</span> ]</span> <span class="keyword">as</span> 'err</span></code></div><div class="spec-doc"><p>Errors the program configured by the CLI can produce. This does not include errors resulting from parsing the CLI. Those are represented by <code>Term.result</code>.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-cmd_result" class="anchored"><a href="#type-cmd_result" class="anchor"></a><code><span><span class="keyword">type</span> <span>('a, 'err) cmd_result</span></span><span> = <span><span>( <span class="type-var">'a</span>, <span><span class="type-var">'err</span> <a href="#type-err">err</a></span> )</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div></div><h3 id="executing-clis"><a href="#executing-clis" class="anchor"></a>Executing CLIs</h3><div class="odoc-spec"><div class="spec module-type" id="module-type-Exec_handler" class="anchored"><a href="#module-type-Exec_handler" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Exec_handler/index.html">Exec_handler</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Default_handler" class="anchored"><a href="#module-Default_handler" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Default_handler/index.html">Default_handler</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Default exit and error handlers for program execution.</p></div></div><div class="odoc-spec"><div class="spec module-type" id="module-type-Exec" class="anchored"><a href="#module-type-Exec" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Exec/index.html">Exec</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Exec" class="anchored"><a href="#module-Exec" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Exec/index.html">Exec</a></span><span> : <a href="module-type-Exec/index.html">Exec</a></span></code></div></div><h3 id="re-exports-from-cmdliner"><a href="#re-exports-from-cmdliner" class="anchor"></a>Re-exports from cmdliner</h3><p>See the Cmdliner documentation for details.</p><div class="odoc-spec"><div class="spec value" id="val-const" class="anchored"><a href="#val-const" class="anchor"></a><code><span><span class="keyword">val</span> const : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="xref-unresolved">Cmdliner</span>.Term.t</span></span></code></div><div class="spec-doc"><p><code>const v : 'a)</code> is a <code>'a Term.t</code>: i.e. is a term that evaluates to <code>v</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-($)" class="anchored"><a href="#val-($)" class="anchor"></a><code><span><span class="keyword">val</span> ($) : 
  <span><span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span> )</span> <span class="xref-unresolved">Cmdliner</span>.Term.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <span class="xref-unresolved">Cmdliner</span>.Term.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'b</span> <span class="xref-unresolved">Cmdliner</span>.Term.t</span></span></code></div><div class="spec-doc"><p><code>f_term $ a_term</code> evalutes to <code>f a</code>: i.e., apply a functional term to argument terms</p></div></div><div class="odoc-spec"><div class="spec value" id="val-unit" class="anchored"><a href="#val-unit" class="anchor"></a><code><span><span class="keyword">val</span> unit : <span>unit <span class="xref-unresolved">Cmdliner</span>.Term.t</span></span></code></div><div class="spec-doc"><p><code>unit</code> evalutes to <code>()</code>, i.e. it is the unit term. Given a function <code>f : unit -&gt; unit</code>), you can <code>let term = lift f $ unit</code> to execuate <code>f</code> when <code>term</code> is evaluated.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Arg" class="anchored"><a href="#module-Arg" class="anchor"></a><code><span><span class="keyword">module</span> Arg</span><span> = <span class="xref-unresolved">Cmdliner</span>.Arg</span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Term" class="anchored"><a href="#module-Term" class="anchor"></a><code><span><span class="keyword">module</span> Term</span><span> = <span class="xref-unresolved">Cmdliner</span>.Term</span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Manpage" class="anchored"><a href="#module-Manpage" class="anchor"></a><code><span><span class="keyword">module</span> Manpage</span><span> = <span class="xref-unresolved">Cmdliner</span>.Manpage</span></code></div></div></div></body></html>