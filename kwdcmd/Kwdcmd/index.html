<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Kwdcmd (kwdcmd.Kwdcmd)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">kwdcmd</a> &#x00BB; Kwdcmd</nav><h1>Module <code>Kwdcmd</code></h1><h2 id="kwdcmd:-keywords-to-write-command-lines"><a href="#kwdcmd:-keywords-to-write-command-lines" class="anchor"></a>KwdCmd: Keywords to Write Command Lines</h2><p>A lightweight and partial porcelain around <a href="https://erratique.ch/software/cmdliner">Cmdliner</a>. Cmdliner is a powerful library for composable command line interfaces, but it is relatively low level. Most users have to look up the documentation every time they want to use the combinators correctly.</p><p>This thin wrapper library is best thought of as an executable cookbook for common Cmdliner usage patterns, or as programmatic documentation encoded in the type level.</p><p>The recipes are divided between module namespaces and detailed with named function arguments.</p><h3 id="ideals"><a href="#ideals" class="anchor"></a>Ideals</h3><ul><li>Remain true to the Cmdliners compositional principles (no side-effecting shortcuts or other chicanery).</li><li>Unfamiliar users should be able to write their CLIs within 10 minutes of reading the docs.</li><li>Familiar users should find everything they need to know to write clean, expressive CLIS's self-documented in the type signatures of the library's modules and functions.</li></ul><p>Please <a href="https://github.com/shonfeder/kwdcmd/issues/new">open an issue</a> or <a href="https://github.com/shonfeder/kwdcmd/blob/master/CONTRIBUTING.org">add a feature</a> if you think the library could be improved to better meet these ideals.</p><h3 id="usage"><a href="#usage" class="anchor"></a>Usage</h3><p>TODO</p><h4 id="example"><a href="#example" class="anchor"></a>Example</h4><pre><code class="ml">open Kwdcmd

(** Application configuration *)
type kind =
  | Bin
  | Lib

type config =
  { name : string
  ; kind : kind
  }

(** Application executor *)
let run : config -&gt; unit = fun _config -&gt; print_endline &quot;TODO&quot;

(** CLI entrypoint *)
let () =
  Exec.run ~name:&quot;My application&quot; ~version:&quot;0.0.1&quot; ~doc:&quot;project generator&quot;
  @@ let+ name =
       Required.pos
         &quot;NAME&quot;
         ~conv:Arg.string
         ~nth:0
         ~doc:&quot;The name of the new project&quot;
         ()
  and+ kind =
    Optional.(
      flag_choice
        ~default:Bin
        [ c ~name:&quot;bin&quot; Bin ~doc:&quot;create an executable binary&quot;
        ; c ~name:&quot;lib&quot; Lib ~doc:&quot;create a library&quot;
        ])
  in
  run { name; kind }</code></pre><nav class="toc"><ul><li><a href="#binding-operators">Binding operators</a></li><li><a href="#constructing-terms">Constructing terms</a></li><li><a href="#re-exports-from-cmdliner">Re-exports from cmdliner</a></li></ul></nav></header><section><header><h3 id="binding-operators"><a href="#binding-operators" class="anchor"></a>Binding operators</h3><p>The beauty of Cmdliner lies in its its applicative and composable API. Using this API is made much cleaner by means of binding operators. Naturally, you are not bound to use these. See the example above for usage.</p></header><dl><dt class="spec value" id="val-let+"><a href="#val-let+" class="anchor"></a><code><span class="keyword">val</span> let+ : <span><span class="type-var">'a</span> Cmdliner.Term.t</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> Cmdliner.Term.t</span></code></dt><dd><p><code>(let+) is Term.(const f $ t)</code></p></dd></dl><dl><dt class="spec value" id="val-and+"><a href="#val-and+" class="anchor"></a><code><span class="keyword">val</span> and+ : <span><span class="type-var">'a</span> Cmdliner.Term.t</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> Cmdliner.Term.t</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> Cmdliner.Term.t</span></code></dt><dd><p><code>(and+) is Term.(const (fun x y -&gt; (x, y)) $ a $ b)</code></p></dd></dl></section><section><header><h3 id="constructing-terms"><a href="#constructing-terms" class="anchor"></a>Constructing terms</h3><p>We build our CLIs by defining composable terms that transform CLI args into OCaml values. Kwdcmd breaks terms into 2 classes.</p></header><dl><dt class="spec module" id="module-Required"><a href="#module-Required" class="anchor"></a><code><span class="keyword">module</span> <a href="Required/index.html">Required</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd></dd></dl><dl><dt class="spec module" id="module-Optional"><a href="#module-Optional" class="anchor"></a><code><span class="keyword">module</span> <a href="Optional/index.html">Optional</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd></dd></dl><aside><p>TODO Document with type annotations</p></aside><dl><dt class="spec type" id="type-cmd"><a href="#type-cmd" class="anchor"></a><code><span class="keyword">type</span> <span>'a cmd</span></code><code> = <span><span class="type-var">'a</span> Cmdliner.Term.t</span> * Cmdliner.Term.info</code></dt></dl><dl><dt class="spec value" id="val-cmd"><a href="#val-cmd" class="anchor"></a><code><span class="keyword">val</span> cmd : <span>?&#8288;man:<span>Cmdliner.Manpage.block list</span></span> <span>&#45;&gt;</span> <span>name:string</span> <span>&#45;&gt;</span> <span>doc:string</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> Cmdliner.Term.t</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-cmd">cmd</a></span></code></dt><dd><p>A subcommand</p></dd></dl><dl><dt class="spec value" id="val-help_cmd"><a href="#val-help_cmd" class="anchor"></a><code><span class="keyword">val</span> help_cmd : <span>?&#8288;version:string</span> <span>&#45;&gt;</span> <span>?&#8288;doc:string</span> <span>&#45;&gt;</span> <span>?&#8288;sdocs:string</span> <span>&#45;&gt;</span> <span>?&#8288;exits:<span>Cmdliner.Term.exit_info list</span></span> <span>&#45;&gt;</span> <span>?&#8288;man:<span>Cmdliner.Manpage.block list</span></span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span><span class="type-var">'a</span> Cmdliner.Term.t</span> * Cmdliner.Term.info</code></dt><dd><p>A custom help command</p></dd></dl><dl><dt class="spec module" id="module-Exec"><a href="#module-Exec" class="anchor"></a><code><span class="keyword">module</span> <a href="Exec/index.html">Exec</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Construct CLI entrypoints</p></dd></dl></section><section><header><h3 id="re-exports-from-cmdliner"><a href="#re-exports-from-cmdliner" class="anchor"></a>Re-exports from cmdliner</h3></header><dl><dt class="spec value" id="val-const"><a href="#val-const" class="anchor"></a><code><span class="keyword">val</span> const : <span class="type-var">'a</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> Cmdliner.Term.t</span></code></dt><dd><p><code>const (v : 'a)</code> is a <code>'a Term.t</code>: i.e. is a term that evaluates to <code>v</code></p></dd></dl><dl><dt class="spec value" id="val-($)"><a href="#val-($)" class="anchor"></a><code><span class="keyword">val</span> ($) : <span><span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'b</span>)</span> Cmdliner.Term.t</span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> Cmdliner.Term.t</span> <span>&#45;&gt;</span> <span><span class="type-var">'b</span> Cmdliner.Term.t</span></code></dt><dd><p><code>f_term $ a_term</code> evalutes to <code>f a</code>: i.e., apply a functional term to argument terms</p></dd></dl><dl><dt class="spec value" id="val-unit"><a href="#val-unit" class="anchor"></a><code><span class="keyword">val</span> unit : <span>unit Cmdliner.Term.t</span></code></dt><dd><p><code>unit</code> evalutes to <code>()</code>, i.e. it is the unit term. Given a function <code>f : unit -&gt; unit</code>), you can <code>let term = lift f $ unit</code> to execuate <code>f</code> when <code>term</code> is evaluated.</p></dd></dl><div class="spec module" id="module-Arg"><a href="#module-Arg" class="anchor"></a><code><span class="keyword">module</span> Arg = Cmdliner.Arg</code></div><div class="spec module" id="module-Term"><a href="#module-Term" class="anchor"></a><code><span class="keyword">module</span> Term = Cmdliner.Term</code></div></section></div></body></html>